The first chapter, “Building Abstractions with Procedures”, briefly touches on
a variety of topics, mostly mathematical in nature. It can be viewed as a
grab bag of tricks that’ll really make you sound like a smartypants...
but the focus nonetheless is never lost; it truly is more about abstractions
and procedures.

# 1.1 The Elements of Programming

Exercises 1.1–1.5 follow sections 1.1.1–1.1.6 (Expressions, Naming and the
Environment, Evaluating Combinations, Compound Procedures, The Substitution
Model for Procedure Application, Conditional Expressions and Predicates).

Exercises 1.6–1.8 follow section 1.1.7 (Example: Square Roots by Newton’s
Method) wherein iteration and stopping conditions are demonstrated.

# 1.2 Procedures and the Processes They Generate

Exercises 1.9–1.10 follow section 1.2.1 (Linear Recursion and Iteration).

Exercises 1.11–1.13 follow section 1.2.2 (Tree Recursion).

Exercises 1.14–1.15 follow section 1.2.3 (Orders of Growth), an important
topic in computer science because computers are fast enough to compute anything
you say right up until you hit some facet of reality that implies it will take
more time than you have.

Exercises 1.16–1.19 follow section 1.2.4 (Exponentiation), one of the standout
features being exponentiation by squaring.

Exercise 1.20 follows section 1.2.5 (Greatest Common Divisors), and

Exercises 1.21–1.28 follow section 1.2.6 (Example: Testing for Primality),
covering not only the stop-at-square-root method, but also Fermat’s Little
Theorem and the Miller–Rabin test.

# 1.3 Formulating Abstractions with Higher-Order Procedures

Exercises 1.29–1.33 follow section 1.3.1 (Procedures as Arguments), which
is not only an introduction to higher-order procedures, but also touches on
numerical integration (calculus) and staples of functional programming
(accumulation and filtering).

Exercise 1.34 follows section 1.3.2 (Constructing Procedures Using Lambda).
Although SICP drives home that naming things is a powerful way to understand
what procedures are really about, some things really don’t need names, which
is also powerful when the implications are fully explored.

Exercises 1.35–1.39 follow section 1.3.3 (Procedures as General Methods),
which really starts to get a little mind-twisty, particularly if you don’t
grok Scheme idiomatically or the mathematics involved doesn’t stick with you.
Discusses half-interval method, fixed points of functions, and continued
fractions for approximating some wily irrational numbers.

Exercises 1.40–1.46 follow section 1.3.4 (Procedures as Returned Values),
where Newton’s Method is rehashed to more than just a square-root finder,
what "first-class" means is described, and miscellaneous numerical methods
are touched upon to cap off the chapter, including further higher-ordering
what we have been higher-ordering already (what a wild ride!).
